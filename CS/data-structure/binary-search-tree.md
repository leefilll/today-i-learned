## 이진탐색트리(Binary Search Tree, BST)

노드의 왼쪽 서브트리는 노드의 값보다 작은 값들을 지니고, 오른쪽 서브트리는 큰 값들을 지니는 이진 트리 자료구조

- 이진탐색과 연결리스트를 결합한 자료구조
  이진탐색의 효율적인 탐색 능력을 유지하면서, 자료 입력과 삭제를 가능하게끔 고안됨

  > 이진탐색의 경우 조회에 O(log n)의 시간복잡도. 그러나 자료 입력과 삭제가 불가능. 연결리스트의 경우 자료 입력, 삭제는 O(1)로 효율적이지만 탐색은 O(n)

- 중복된 값을 허용하지 않음
- 왼쪽 서브트리와 오른쪽 서브트리 모두 이진탐색트리

### 탐색

- 루트 노드와 먼저 비교
- 같으면 루트 노드를 반환
- 작으면 왼쪽 서브트리로 재귀 검색, 크다면 오른쪽 서브트리로 재귀 검색
- 중위 순회(Inorder Traversal)을 통해서 모든 키를 정렬된 순서로 가져올 수 있음
  균형 상태일 경우 O(log n)의 시간복잡도, 불균형 상태라면 O(n)이 걸림
  => **AVL 트리**가 제안됨

  > AVL 트리는 트리의 불균형을 막기위해 새로운 노드가 트리에 추가될 때마다 좌측 서브트리와 우측 서브트리의 높이의 차를 사용해 트리의 균형을 맞춤. 만약 불균형이 발견되면 세 루트노드 중 중간 값을 가진 노드를 루트노드로 만들고 이를 기준으로 좌우에 서브트리를 위치시킴. 시간복잡도는 항상 O(log n)

  ![R1280x0](https://user-images.githubusercontent.com/38246878/146646474-15fb4502-e5c1-4621-bf1b-ecdcb116c8a8.png)

### 삽입

- 새 노드는 항상 리프 노드에 삽입됨

![R1280x0-3](https://user-images.githubusercontent.com/38246878/146646868-a7f75449-06a6-4d95-ba0b-f8358ded7e02.png)

1. 루트 노드와 비교
2. 작다면 왼쪽 서브트리로 재귀, 크다면 오른쪽 서브트리로 재귀
3. 리프 노드에 도달하여 작으면 왼쪽에 삽입, 크다면 오른쪽에 삽입

### 삭제

- **삭제할 노드의 자식이 없는 경우**
  1. 노드를 삭제하고 반환
     <br/>
- **삭제할 노드의 자식이 한 개 있는 경우**
  1. 삭제할 노드의 자식 노드를 삭제할 노드의 부모에 직접 연결
  2. 노드를 삭제하고 반환
     <br/>
- **삭제할 노드의 자식이 두 개 있는 경우**
  ![R1280x0-2](https://user-images.githubusercontent.com/38246878/146646675-8f2f4186-dd7d-4324-8f4c-0ab13b054cb9.png)

  1. 삭제할 노드를 찾음
  2. 삭제할 노드의 오른쪽 서브트리의 최솟값(중위 순회에서 바로 다음에 올 값, successor라고 부름)을 찾음
  3. 서로 값을 바꾸어줌
  4. 원래 삭제하려고 했던 노드가 자식이 없거나 하나만 있기 때문에 위 과정을 삭제
     <br/>
